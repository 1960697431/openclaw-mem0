
import * as fs from "node:fs";
import * as path from "node:path";
import { type OpenClawPluginApi } from "openclaw/plugin-sdk";
import { type Mem0Provider } from "./types.js";

export class MemoryIngestor {
  private watchers: fs.FSWatcher[] = [];
  private processedFiles = new Map<string, string>();
  private debounceTimers = new Map<string, NodeJS.Timeout>();

  constructor(
    private readonly workspaceDir: string,
    private readonly provider: Mem0Provider,
    private readonly logger: OpenClawPluginApi["logger"],
    private readonly userId: string
  ) {}

  start() {
    const memoryDir = path.join(this.workspaceDir, "memory");
    
    // Ensure dir exists
    if (!fs.existsSync(memoryDir)) {
      this.logger.debug?.(`[mem0-ingestor] Memory dir not found: ${memoryDir}`);
      return;
    }

    this.logger.info(`[mem0] ğŸ“¡ å¯åŠ¨è®°å¿†æ‘„å…¥å™¨: ç›‘å¬ ${memoryDir}`);

    // Watch for new/changed files
    try {
      const watcher = fs.watch(memoryDir, (eventType, filename) => {
        if (!filename || !filename.endsWith(".md")) return;
        
        const filePath = path.join(memoryDir, filename);
        this.handleFileChange(filePath);
      });
      this.watchers.push(watcher);

      // Also watch MEMORY.md in root workspace if it exists
      const rootMemory = path.join(this.workspaceDir, "MEMORY.md");
      if (fs.existsSync(rootMemory)) {
        const rootWatcher = fs.watch(rootMemory, () => this.handleFileChange(rootMemory));
        this.watchers.push(rootWatcher);
      }

    } catch (err) {
      this.logger.warn(`[mem0] Failed to start file watcher: ${err}`);
    }
  }

  stop() {
    this.watchers.forEach(w => w.close());
    this.watchers = [];
    this.processedFiles.clear();
  }

  private handleFileChange(filePath: string) {
    // Debounce: wait 5s after last write to ensure file is complete
    if (this.debounceTimers.has(filePath)) {
      clearTimeout(this.debounceTimers.get(filePath)!);
    }

    const timer = setTimeout(() => {
      this.ingestFile(filePath);
      this.debounceTimers.delete(filePath);
    }, 5000);

    this.debounceTimers.set(filePath, timer);
  }

  private async ingestFile(filePath: string) {
    try {
      if (!fs.existsSync(filePath)) return;

      const stats = fs.statSync(filePath);
      const fingerprint = `${stats.size}:${Math.floor(stats.mtimeMs)}`;
      if (this.processedFiles.get(filePath) === fingerprint) {
        return;
      }
      // Ignore files older than 1 minute (avoid re-ingesting old files on startup if we were to scan them)
      // But for watcher events, they are fresh.
      
      const content = fs.readFileSync(filePath, "utf-8");
      if (content.length < 50) return; // Skip empty/tiny files

      const filename = path.basename(filePath);
      this.logger.info(`[mem0] ğŸ“¥ æ£€æµ‹åˆ°è®°å¿†æ–‡ä»¶æ›´æ–°: ${filename}ï¼Œæ­£åœ¨æ‘„å…¥ç²¾å...`);

      // Construct a prompt that tells LLM this is a high-value summary
      const ingestionPrompt = `
SYSTEM NOTICE: The following text is a COMPRESSED MEMORY SUMMARY generated by the system from a long conversation.
It contains high-value facts, decisions, and context.
Please extract all relevant information into long-term memory.

--- START SUMMARY (${filename}) ---
${content}
--- END SUMMARY ---
`;

      // Ingest
      const res = await this.provider.add(
        [{ role: "user", content: ingestionPrompt }], 
        { user_id: this.userId }
      );
      
      if (res.results.length > 0) {
        this.logger.info(`[mem0] âœ… æˆåŠŸä»æ–‡ä»¶æ‘„å…¥ ${res.results.length} æ¡è®°å¿†ç²¾å`);
      } else {
        this.logger.debug?.(`[mem0] æ–‡ä»¶æ‘„å…¥å®Œæˆï¼Œä½†æœªæå–åˆ°æ–°è®°å¿† (å¯èƒ½å·²å­˜åœ¨)`);
      }

      this.processedFiles.set(filePath, fingerprint);

    } catch (err) {
      this.logger.warn(`[mem0] Error ingesting file ${filePath}: ${err}`);
    }
  }
}
